DATA STRUCTURES AND ALGORITHMS



NODES


Nodes are the backbones of most of the other data structures. They can hold different types of values such as integers, strings, and arrays. They point to another node. If the pointer returns NULL, then you have reached the end of the node chain. 

Nodes can be orphaned if there are no existing links to them
	a -> n -> t #to remove n but preserve t
	a -> t




# Create the Node class below:
class Node:
  def __init__(self, value, link_node = None):
    self.value = value
    self.link_node = link_node

  # Define your get_value and get_link_node methods below:
  def get_value(self):
    return self.value

  def get_link_node(self):
    return self.link_node

  # Define your set_link_node method below:
  def set_link_node(self, link_node):
    self.link_node = link_node
  


# Add your code below:

yacko = Node('likes to yak')
wacko = Node('has a penchant for hoarding snacks')
dot = Node('enjoys spending time in movie lots')

yacko.set_link_node(dot)
dot.set_link_node(wacko)

dots_data = yacko.get_link_node().get_value()
wackos_data = dot.get_link_node().get_value()

print(dots_data)
print(wackos_data)


#enjoys spending time in movie lots
#has a penchant for hoarding snacks







LINKED LISTS


Linked Lists:

Are comprised of nodes
The nodes contain a link to the next node (and also the previous node for bidirectional linked lists)
Can be unidirectional or bidirectional
Are a basic data structure, and form the basis for many other data structures
Have a single head node, which serves as the first node in the list
Require some maintenance in order to add or remove nodes
The methods we used are an example and depend on the exact use case and/or programming language being used



# We'll be using our Node class
class Node:
  def __init__(self, value, next_node=None):
    self.value = value
    self.next_node = next_node
    
  def get_value(self):
    return self.value
  
  def get_next_node(self):
    return self.next_node
  
  def set_next_node(self, next_node):
    self.next_node = next_node


# Create your LinkedList class below:

class LinkedList:
  def __init__(self, value=None):
    self.head_node = Node(value)

  def get_head_node(self):
    return self.head_node



# Add your insert_beginning and stringify_list methods below:

  def insert_beginning(self, new_value):
    new_node = Node(new_value)
    new_node.set_next_node(self.head_node)
    self.head_node = new_node

  
  def stringify_list(self):
    strlist = ''
    currentNode = self.head_node
    while currentNode:
      if currentNode.get_value() != None:
        strlist+= str(currentNode.get_value()) + "\n"
      currentNode = currentNode.get_next_node()
    return strlist

#Remove node method
  def remove_node(self, value_to_remove):
    current_node = self.get_head_node()
    if current_node.get_value() == value_to_remove:
      self.head_node = current_node.get_next_node()
    else:
      while current_node:
        next_node = current_node.get_next_node()
        if next_node.get_value() == value_to_remove:
          current_node.set_next_node(next_node.get_next_node())
          current_node = None
        else:
          current_node = next_node


# Test your code by uncommenting the statements below - did your list print to the terminal?
ll = LinkedList(5)
ll.insert_beginning(70)
ll.insert_beginning(5675)
ll.insert_beginning(90)
print(ll.stringify_list())

#OUTPUT

90
5675
70
5








DOUBLY LINKED LIST



CONCEPTS

- a doubly linked list has data and two pointers. One points to the next node and the other points to the previous node. The first node, the previous_node is null, and the last node has a next_node value of null


Common operations on a doubly linked list may include:

adding nodes to both ends of the list
removing nodes from both ends of the list
finding, and removing, a node from anywhere in the list
traversing (or traveling through) the list



Adding to the Head

If the list is not empty:

Set the current head’s previous pointer to our new head
Set the new head’s next pointer to the current head
Set the new head’s previous pointer to null


Adding to the Tail

Set the current tail’s next pointer to the new tail
Set the new tail’s previous pointer to the current tail
Set the new tail’s next pointer to null


Removing the Head

Removing the head involves updating the pointer at the beginning of the list. We will set the previous pointer of the new head (the element directly after the current head) to null, and update the head property of the list. If the head was also the tail, the tail removal process will occur as well.


Removing the Tail

Similarly, removing the tail involves updating the pointer at the end of the list. We will set the next pointer of the new tail (the element directly before the tail) to null, and update the tail property of the list. If the tail was also the head, the head removal process will occur as well.


Removing from the middle of the list

We must set the removed node’s preceding node’s next pointer to its following node
We must set the removed node’s following node’s previous pointer to its preceding node



PYTHON DOUBLY LINKED LISTS


class Node:
  def __init__(self, value, next_node=None, prev_node=None):
    self.value = value
    self.next_node = next_node
    self.prev_node = prev_node
    
  def set_next_node(self, next_node):
    self.next_node = next_node
    
  def get_next_node(self):
    return self.next_node

  def set_prev_node(self, prev_node):
    self.prev_node = prev_node
    
  def get_prev_node(self):
    return self.prev_node
  
  def get_value(self):
    return self.value
    

class DoublyLinkedList:
  def __init__(self):
    self.head_node = None
    self.tail_node = None
  
  def add_to_head(self, new_value):
    new_head = Node(new_value)
    current_head = self.head_node

    if current_head != None:
      current_head.set_prev_node(new_head)
      new_head.set_next_node(current_head)

    self.head_node = new_head

    if self.tail_node == None:
      self.tail_node = new_head

  def add_to_tail(self, new_value):
    new_tail = Node(new_value)
    current_tail = self.tail_node

    if current_tail != None:
      current_tail.set_next_node(new_tail)
      new_tail.set_prev_node(current_tail)

    self.tail_node = new_tail

    if self.head_node == None:
      self.head_node = new_tail

  def remove_head(self):
    removed_head = self.head_node

    if removed_head == None:
      return None

    self.head_node = removed_head.get_next_node()

    if self.head_node != None:
      self.head_node.set_prev_node(None)

    if removed_head == self.tail_node:
      self.remove_tail()

    return removed_head.get_value()

  def remove_tail(self):
    removed_tail = self.tail_node

    if removed_tail == None:
      return None

    self.tail_node = removed_tail.get_prev_node()

    if self.tail_node != None:
      self.tail_node.set_next_node(None)

    if removed_tail == self.head_node:
      self.remove_head()

    return removed_tail.get_value()

  def remove_by_value(self, value_to_remove):
    node_to_remove = None
    current_node = self.head_node

    while current_node != None:
      if current_node.get_value() == value_to_remove:
        node_to_remove = current_node
        break

      current_node = current_node.get_next_node()

    if node_to_remove == None:
      return None

    if node_to_remove == self.head_node:
      self.remove_head()
    elif node_to_remove == self.tail_node:
      self.remove_tail()
    else:
      next_node = node_to_remove.get_next_node()
      prev_node = node_to_remove.get_prev_node()
      next_node.set_prev_node(prev_node)
      prev_node.set_next_node(next_node)

    return node_to_remove

  def stringify_list(self):
    string_list = ""
    current_node = self.head_node
    while current_node:
      if current_node.get_value() != None:
        string_list += str(current_node.get_value()) + "\n"
      current_node = current_node.get_next_node()
    return string_list





Swapping Elements in a Linked List


def swap_nodes(input_list, val1, val2):
  print(f'Swapping {val1} with {val2}')

  node1_prev = None
  node2_prev = None
  node1 = input_list.head_node
  node2 = input_list.head_node

  if val1 == val2:
    print("Elements are the same - no swap needed")
    return

  while node1 is not None:
    if node1.get_value() == val1:
      break
    node1_prev = node1
    node1 = node1.get_next_node()

  while node2 is not None:
    if node2.get_value() == val2:
      break
    node2_prev = node2
    node2 = node2.get_next_node()

  if (node1 is None or node2 is None):
    print("Swap not possible - one or more element is not in the list")
    return

  if node1_prev is None:
    input_list.head_node = node2
  else:
    node1_prev.set_next_node(node2)

  if node2_prev is None:
    input_list.head_node = node1
  else:
    node2_prev.set_next_node(node1)

  temp = node1.get_next_node()
  node1.set_next_node(node2.get_next_node())
  node2.set_next_node(temp)


ll = LinkedList.LinkedList()
for i in range(10):
  ll.insert_beginning(i)

print(ll.stringify_list())
swap_nodes(ll, 9, 5)
print(ll.stringify_list())





Two pointer linkedList technique


Finding the nth last element in a LinkedList


from LinkedList import LinkedList

# Complete this function:
def nth_last_node(linked_list, n):
  tail_pointer = linked_list.head_node
  nth_last = None
  count = 1

  while tail_pointer != None:
    tail_pointer = tail_pointer.next_node
    count+=1

    if count >= n+1:
      if nth_last == None:
        nth_last = linked_list.head_node
      else:
        nth_last = nth_last.next_node
  return nth_last


def generate_test_linked_list():
  linked_list = LinkedList()
  for i in range(50, 0, -1):
    linked_list.insert_beginning(i)
  return linked_list

# Use this to test your code:
test_list = generate_test_linked_list()
print(test_list.stringify_list())
nth_last = nth_last_node(test_list, 4)
print(nth_last.value)



Finding the middle pointer using two pointers moving at different speeds

def find_middle(linked_list):
  fast = linked_list.head_node
  slow = linked_list.head_node
  while fast:
    fast = fast.get_next_node()
    if fast:
      fast = fast.get_next_node()
      slow = slow.get_next_node()
  return slow






SEARCHING ARRAYS

Concepts

- Linear Search: Going through an array one element at a time
 
Not very efficient

Best Case: O(1)
Worst Case: O(N)
Average Case: O(N/2) => O(N)



- Binary Search: Check middle value, if it is less than the target, use the right half of the array, else use the left half. If it is the target, then return the middle value. Keep doing these steps until you remain with one value. (LIST MUST BE SORTED)

Time Complexity:

Since for each iteration we are cutting the list in half, the time complexity is: O(log N)





Implementing in Python


Linear Search

#finding target and its duplicates

def linear_search(search_list, target_value):
  matches = []
  for idx in range(len(search_list)):
    if search_list[idx] == target_value:
      matches.append(idx)
  if matches:
    return matches
  else:
    raise ValueError("{0} not in list".format(target_value))

number_list = [ 10, 14, 19, 26, 27, 31, 33, 35, 42, 44]
target_number = 100

try:
  # Call the function below...
  result = linear_search(number_list, target_number)
  print(result)

except ValueError as error_message:
  print("{0}".format(error_message))


#finding max value

# Search list
test_scores = [88, 93, 75, 100, 80, 67, 71, 92, 90, 83]

#Linear Search Algorithm
def linear_search(search_list):
  maximum_score_index = None
  for idx in range(len(search_list)):
    if not maximum_score_index or search_list[idx] > search_list[maximum_score_index]:
      maximum_score_index = idx
  return maximum_score_index

# Function call
highest_score = linear_search(test_scores)

#Prints out the highest score in the list
print(highest_score)





Binary Search

Using recursion

def binary_search(sorted_list, target):
  if not sorted_list:
    return 'value not found'
  mid_idx = len(sorted_list)//2
  mid_val = sorted_list[mid_idx]
  if mid_val == target:
    return mid_idx
  if mid_val > target:
    left_half = sorted_list[:mid_idx]
    return binary_search(left_half, target)
  if mid_val < target:
    right_half = sorted_list[mid_idx:]
    result = binary_search(right_half, target)
    return result + mid_idx + 1


Using Pointers

def binary_search(sorted_list, left_pointer, right_pointer, target):
  # this condition indicates we've reached an empty "sub-list"
  if left_pointer >= right_pointer:
    return "value not found"
	
  # We calculate the middle index from the pointers now
  mid_idx = (left_pointer + right_pointer) // 2
  mid_val = sorted_list[mid_idx]

  if mid_val == target:
    return mid_idx
  if mid_val > target:
    # we reduce the sub-list by passing in a new right_pointer
    return binary_search(sorted_list, left_pointer, mid_idx, target)
  if mid_val < target:
    # we reduce the sub-list by passing in a new left_pointer
    return binary_search(sorted_list, mid_idx + 1, right_pointer, target)




Using Iteration

def binary_search(sorted_list, target):
  left_pointer = 0
  right_pointer = len(sorted_list)
  
  # fill in the condition for the while loop
  while left_pointer < right_pointer:
    # calculate the middle index using the two pointers
    mid_idx = (left_pointer + right_pointer) // 2
    mid_val = sorted_list[mid_idx]
    if mid_val == target:
      return mid_idx
    if target < mid_val:
      # set the right_pointer to the appropriate value
      right_pointer = mid_idx
    if target > mid_val:
      # set the left_pointer to the appropriate value
      left_pointer = mid_idx + 1
  
  return "Value not in list"



